<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SputnikChat - MudBall Arena</title>
    
    <!-- Librerie -->
    <script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <style>
        /* FONT */
        @font-face { font-family: 'Planewalker'; src: url('./Planewalker.woff') format('woff'); }
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; font-family: 'Planewalker', sans-serif; background: #111; user-select: none; }
        button, input { font-family: 'Planewalker', sans-serif; }
        
        /* UI LAYOUT */
        #login-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; color: white;
        }
        #nickname-input { 
            padding: 15px; font-size: 24px; text-align: center; background-color: #222; color: #ffff00;
            border: 2px solid #555; border-radius: 8px; outline: none; width: 300px;
        }
        #play-btn { margin-top: 20px; padding: 10px 30px; font-size: 50px; cursor: pointer; background: transparent; color: #ffff00; border: none; }

        /* HUD SCHEDA (SCALATA) */
        #ui-container-wrapper { position: absolute; top: 10px; left: 10px; width: 300px; height: 400px; z-index: 20; pointer-events: none; }
        #ui-scale-wrapper { transform: scale(0.13); transform-origin: top left; width: 2106px; height: 2956px; pointer-events: auto; }
        
        .Texture {
            background-image: url("Texture.png"); background-color: #1a1a1a;
            border: 10px solid #111; border-radius: 40px; position: absolute; width: 100%; height: 100%;
            box-shadow: inset 0 0 0 20px rgba(255, 255, 255, 0.9), inset 0 0 20px 20px rgba(0,0,0,0.2);
        }
        /* Effetto Incassato Comune */
        .incassato {
            box-shadow: inset -6px 6px 12px rgba(0, 0, 0, 0.9), inset 3px -3px 6px rgba(255, 255, 255, 0.1), 0 2px 4px rgba(0,0,0,0.5);
            border: 2px solid #111;
        }
        
        .nome_giocatore {
            background-color: rgba(34, 32, 30, 0.6); position: absolute; left: 269px; top: 144px; width: 1560px; height: 212px;
            color: #ffff00; font-size: 140px; display: flex; align-items: center; justify-content: center;
        }
        .skin {
            background-color: rgba(34, 32, 30, 0.6); position: absolute; left: 269px; top: 411px; width: 1560px; height: 211px;
            color: #ccc; font-size: 100px; display: flex; align-items: center; justify-content: center;
        }
        .immagine {
            background-color: rgb(34, 32, 30); position: absolute; left: 270px; top: 694px; width: 1559px; height: 1560px;
            overflow: hidden; display: flex; align-items: center; justify-content: center;
        }
        .immagine img { width: 100%; height: 100%; object-fit: cover; }
        
        .skin-arrow {
            position: absolute; top: 0; bottom: 0; width: 200px; background: transparent; border: none; color: white;
            font-size: 150px; cursor: pointer; z-index: 10;
        }
        .skin-arrow:hover { background: rgba(255, 187, 0, 0.4); color: #ffff00; }
        .arrow-left { left: 0; } .arrow-right { right: 0; }

        .microfono, .musica {
            background-color: rgba(34, 32, 30, 0.6); position: absolute; top: 2326px; width: 752px; height: 492px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        .microfono { left: 269px; } .musica { left: 1078px; }
        .microfono i, .musica i { font-size: 200px; color: #888; opacity: 0.5; }
        .active i { color: #00ff00; opacity: 1; }
        .music-on i { color: #0088ff; opacity: 1; }

        /* SCOREBOARD MINIGAME */
        #game-ui {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; z-index: 50; pointer-events: none;
        }
        .hud-box {
            background: rgba(0, 0, 0, 0.7); border: 2px solid #555; padding: 10px 20px; border-radius: 10px;
            color: #ffff00; font-size: 24px; text-shadow: 2px 2px 0 #000; text-align: center;
        }
        #freeze-warning {
            color: #00ffff; display: none;
        }

        #instructions {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 10px; z-index: 10; display: none; text-align: center;
        }
        #chat-container {
            position: absolute; bottom: 20px; right: 20px; width: 320px; height: 250px;
            background: rgba(0, 0, 0, 0.5); border-radius: 8px; z-index: 50; display: flex; flex-direction: column; padding: 10px; pointer-events: auto;
        }
        #chat-messages { flex-grow: 1; overflow-y: auto; color: white; font-size: 18px; margin-bottom: 5px; }
        .chat-name { color: #ffff00; margin-right: 5px; }
        #chat-input { background: rgba(255,255,255,0.1); border: 1px solid #555; color: white; padding: 8px; }
    </style>
</head>
<body>

    <div id="login-overlay" style="pointer-events: auto;">
        <h1 style="font-size: 50px;">MudBall Arena</h1>
        <input id="nickname-input" type="text" placeholder="Nickname" maxlength="12" autofocus>
        <button id="play-btn">ENTRA</button>
    </div>

    <!-- HUD MINIGAME -->
    <div id="game-ui">
        <div class="hud-box">Punti: <span id="score-display">0</span></div>
        <div class="hud-box" id="freeze-warning">CONGELATO!</div>
    </div>

    <div id="ui-container-wrapper">
        <div id="ui-scale-wrapper">
            <div class="Texture">
                <div class="nome_giocatore incassato" id="hud-name">PLAYER</div>
                <div class="skin incassato" id="skin-label">Skin: ...</div>
                <div class="immagine incassato">
                    <button class="skin-arrow arrow-left" id="prev-skin-btn">&lt;</button>
                    <img id="hud-propic" src="" alt="Profile">
                    <button class="skin-arrow arrow-right" id="next-skin-btn">&gt;</button>
                </div>
                <div class="microfono incassato" id="mic-btn"><i class="fa-solid fa-microphone-slash" id="mic-icon"></i></div>
                <div class="musica incassato" id="music-btn"><i class="fa-solid fa-music" id="music-icon"></i></div>
            </div>
        </div>
    </div>

    <div id="instructions">
        <h1>Comandi</h1>
        <p><b>WASD</b>: Muovi | <b>MOUSE</b>: Guarda<br><b>CLICK SX</b>: Spara Fango<br><b>INVIO</b>: Chat | <b>M</b>: Mic</p>
    </div>

    <div id="chat-container">
        <div id="chat-messages"></div>
        <input id="chat-input" type="text" placeholder="Scrivi..." autocomplete="off">
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURAZIONE ---
        const SOCKET_URL = "https://sputnikchat-1.onrender.com"; 
        const MUSIC_FILE = "./soundtrack.mp3"; 
        const MUD_SPEED = 25.0;     // VelocitÃ  palla
        const SHOT_COOLDOWN = 500;  // ms
        const FREEZE_HITS = 5;      // Colpi per congelare
        const FREEZE_TIME = 5000;   // Durata congelamento

        // Variabili Three.js
        let scene, camera, renderer, loader, socket;
        let playerGroup, avatarMesh;
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
        let canJump=false, isLocked=false, isThirdPerson=false;
        let velocity = new THREE.Vector3();
        const GRAVITY = 30.0;
        let theta = 0, phi = 0;

        // Variabili Gioco
        let mySkin="plebeo.png", myName="Anonimo", gameInitialized=false;
        const remotePlayers = {}; // id -> mesh
        const wallMeshes=[], colliders=[], torchLights=[];
        let wallTexture, floorTexture, torchAnimatedTexture;
        let bullets = []; // { mesh, velocity, shooterId, life }
        
        // Stato Minigame
        let myScore = 0;
        let myHitsTaken = 0;
        let isFrozen = false;
        let lastShotTime = 0;
        let scores = {}; // id -> score

        // Audio & Avatar
        let localStream=null, bgMusic=null, isMusicOn=false, isMicActive=false;
        const peers={};
        let currentSkinIndex = 0;
        const avatarOptions = [
            { label: "Ratto", file: "Personaggi/Rat.png", propic: "Personaggi/Rat_propic.png" },
            { label: "Alessandro", file: "Personaggi/Alessandro.png", propic: "Personaggi/Alessandro_propic.png" },
            { label: "Francesco", file: "Personaggi/Francesco.png", propic: "Personaggi/Francesco_propic.png" }
        ];

        // --- UTILS GRAFICHE ---
        function createNameTagSprite(name) {
            const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "rgba(0,0,0,0.5)"; 
            ctx.beginPath(); ctx.roundRect(4,4,248,56,15); ctx.fill();
            ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.lineWidth=3; ctx.stroke();
            ctx.font="28px Planewalker, sans-serif"; ctx.fillStyle="#ffff00"; ctx.textAlign="center"; ctx.textBaseline="middle";
            ctx.fillText(name.slice(0,16), 128, 32);
            const tex = new THREE.CanvasTexture(canvas);
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false }));
            spr.scale.set(2.0, 0.5, 1);
            return spr;
        }

        function createCrownSprite() {
            const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
            const ctx = canvas.getContext('2d');
            ctx.font="50px serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
            ctx.fillText("ðŸ‘‘", 32, 36); // Emoji Corona
            const tex = new THREE.CanvasTexture(canvas);
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false }));
            spr.scale.set(1, 1, 1);
            return spr;
        }

        function setOrUpdateNameTag(parent, name) {
            if(parent.userData.tag) parent.remove(parent.userData.tag);
            const tag = createNameTagSprite(name);
            tag.position.set(0, 1.9, 0);
            parent.add(tag);
            parent.userData.tag = tag;
            
            // Aggiungi anche slot corona se non c'Ã¨
            if(!parent.userData.crown) {
                const crown = createCrownSprite();
                crown.position.set(0, 2.4, 0);
                crown.visible = false;
                parent.add(crown);
                parent.userData.crown = crown;
            }
        }

        // --- LOGIN & AVVIO ---
        setupLogin();
        function setupLogin() {
            const btn = document.getElementById('play-btn');
            const input = document.getElementById('nickname-input');
            const start = async () => {
                if(gameInitialized) return; gameInitialized=true;
                myName = input.value.trim() || "Anonimo";
                document.getElementById('hud-name').innerText = myName;
                scores[socket?.id || 'me'] = 0; // init score

                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    localStream.getAudioTracks()[0].enabled = false;
                } catch(e) { console.log("No Mic"); }

                document.getElementById('login-overlay').style.display='none';
                document.getElementById('instructions').style.display='block';
                init(); initSocket(); animate();
            };
            btn.onclick = start; input.onkeydown = e => { if(e.key==='Enter') start(); };
        }

        // --- INIT THREEJS ---
        function init() {
            scene = new THREE.Scene();
            
            // CIELO CREPUSCOLARE
            const cvs = document.createElement('canvas'); cvs.width=1; cvs.height=32;
            const ctx = cvs.getContext('2d');
            const grd = ctx.createLinearGradient(0,0,0,32);
            grd.addColorStop(0, '#0b001a'); grd.addColorStop(0.4, '#2d0a45'); 
            grd.addColorStop(0.7, '#751e5e'); grd.addColorStop(1, '#ffaa00');
            ctx.fillStyle = grd; ctx.fillRect(0,0,1,32);
            scene.background = new THREE.CanvasTexture(cvs);
            scene.fog = new THREE.Fog(0x2d0a45, 10, 60);

            camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
            scene.add(camera);

            loader = new THREE.TextureLoader();
            wallTexture = loader.load('./muro.jpg');
            floorTexture = loader.load('./pavimento.jpg');
            if(floorTexture) { floorTexture.wrapS=floorTexture.wrapT=THREE.RepeatWrapping; floorTexture.repeat.set(15,15); }

            // Torcia Gif
            const gCvs = document.createElement('canvas'); gCvs.width=512; gCvs.height=512;
            torchAnimatedTexture = new THREE.CanvasTexture(gCvs);
            try { window.gifler('./torcia.gif').animate(gCvs); } catch(e){}

            // Player Locale
            playerGroup = new THREE.Group();
            avatarMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 1.7), 
                new THREE.MeshStandardMaterial({ transparent:true, side:THREE.DoubleSide, alphaTest:0.5 })
            );
            avatarMesh.position.set(0, 0.85, 0);
            avatarMesh.visible = false; 
            playerGroup.add(avatarMesh);
            setOrUpdateNameTag(playerGroup, myName);
            playerGroup.userData.tag.visible = false; // Nascondi tag locale in 1a persona
            scene.add(playerGroup);

            setupAvatarUI(); setupMicButton(); setupMusic();
            buildLevel();

            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            document.body.appendChild(renderer.domElement);

            // Input
            document.addEventListener('click', () => {
                if(!isLocked && document.getElementById('login-overlay').style.display==='none') document.body.requestPointerLock();
                else if(isLocked) shootBall(); // SPARO COL CLICK
            });
            document.addEventListener('pointerlockchange', () => {
                isLocked = (document.pointerLockElement === document.body);
                document.getElementById('instructions').style.display = isLocked ? 'none' : 'block';
            });
            document.addEventListener('mousemove', e => {
                if(isLocked && !isFrozen) {
                    theta -= e.movementX * 0.002;
                    phi = Math.max(-1.5, Math.min(1.5, phi + e.movementY * 0.002));
                }
            });
            
            // Tasti
            const chatIn = document.getElementById('chat-input');
            document.addEventListener('keydown', e => {
                if(document.activeElement===chatIn) {
                    if(e.code==='Enter' && chatIn.value.trim()) { socket.emit('chatMessage', chatIn.value.trim()); chatIn.value=''; }
                    if(e.code==='Escape') { chatIn.blur(); document.body.requestPointerLock(); }
                    return;
                }
                if(e.code==='Enter') { document.exitPointerLock(); chatIn.focus(); return; }
                if(isFrozen) return; // BLOCCO INPUT SE CONGELATO

                if(e.code==='KeyM') toggleMic();
                if(e.code==='KeyB') toggleMusic();
                if(e.code==='KeyF') shootBall(); // SPARO CON F

                switch(e.code) {
                    case 'KeyW': moveForward=true; break;
                    case 'KeyS': moveBackward=true; break;
                    case 'KeyA': moveLeft=true; break;
                    case 'KeyD': moveRight=true; break;
                    case 'Space': if(canJump) { velocity.y+=12; canJump=false; } break;
                    case 'KeyV': 
                        isThirdPerson=!isThirdPerson; avatarMesh.visible=isThirdPerson; 
                        if(playerGroup.userData.tag) playerGroup.userData.tag.visible=isThirdPerson;
                        break;
                }
            });
            document.addEventListener('keyup', e => {
                switch(e.code) {
                    case 'KeyW': moveForward=false; break;
                    case 'KeyS': moveBackward=false; break;
                    case 'KeyA': moveLeft=false; break;
                    case 'KeyD': moveRight=false; break;
                }
            });
            window.onresize = () => { camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); };
        }

        // --- LOGICA MINIGAME ---
        function shootBall() {
            if(isFrozen || !socket) return;
            const now = Date.now();
            if(now - lastShotTime < SHOT_COOLDOWN) return;
            lastShotTime = now;

            // Calcola direzione sparo
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const startPos = playerGroup.position.clone();
            startPos.y += 1.5; // Altezza occhi
            
            // Crea palla locale
            createBullet(startPos, dir, socket.id);

            // Invia agli altri (uso un evento custom 'gameEvent' per sicurezza)
            socket.emit('chatMessage', `__SHOOT__:${startPos.x},${startPos.y},${startPos.z},${dir.x},${dir.y},${dir.z}`);
        }

        function createBullet(pos, dir, shooterId) {
            const geo = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Marrone fango
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            
            bullets.push({
                mesh: mesh,
                velocity: dir.multiplyScalar(MUD_SPEED),
                shooterId: shooterId,
                life: 2.0 // secondi di vita
            });
        }

        function handleHit(shooterId) {
            if(isFrozen) return; // GiÃ  congelato, ignora
            myHitsTaken++;
            
            // Notifica che sono stato colpito
            socket.emit('chatMessage', `__HIT__:${shooterId}:${socket.id}`);
            
            if(myHitsTaken >= FREEZE_HITS) {
                freezePlayer();
            }
        }

        function freezePlayer() {
            isFrozen = true;
            document.getElementById('freeze-warning').style.display = 'block';
            avatarMesh.material.color.setHex(0x00ffff); // Colore Ghiaccio
            socket.emit('skinChange', "FROZEN"); // Hack visivo per gli altri
            
            setTimeout(() => {
                isFrozen = false;
                myHitsTaken = 0;
                document.getElementById('freeze-warning').style.display = 'none';
                avatarMesh.material.color.setHex(0xffffff); // Reset
                socket.emit('skinChange', mySkin); // Ripristina skin
            }, FREEZE_TIME);
        }

        function updateBullets(dt) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.life -= dt;
                
                // Movimento
                const moveStep = b.velocity.clone().multiplyScalar(dt);
                b.mesh.position.add(moveStep);

                // Collisione Muri (semplice check bounds o raycast futuro)
                // Per ora rimuoviamo solo a tempo

                // Collisione con ME STESSO (Se non l'ho sparata io)
                if (b.shooterId !== socket.id && !isFrozen) {
                    const dist = b.mesh.position.distanceTo(playerGroup.position.clone().add(new THREE.Vector3(0,1,0)));
                    if(dist < 0.8) {
                        handleHit(b.shooterId);
                        scene.remove(b.mesh);
                        bullets.splice(i, 1);
                        continue;
                    }
                }

                if (b.life <= 0) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function updateCrowns() {
            // Trova ID con punteggio massimo
            let maxScore = -1;
            let winnerId = null;
            
            // Includi me stesso
            scores[socket.id] = myScore;
            
            for(let id in scores) {
                if(scores[id] > maxScore) {
                    maxScore = scores[id];
                    winnerId = id;
                }
            }

            // Se pareggio o 0 punti, nessuno vince
            // (Semplificazione: il primo trovato vince)

            // Aggiorna visibilitÃ  corona locale
            if(playerGroup.userData.crown) playerGroup.userData.crown.visible = (winnerId === socket.id && maxScore > 0);

            // Aggiorna remoti
            for(let id in remotePlayers) {
                const p = remotePlayers[id];
                if(p.userData.crown) p.userData.crown.visible = (id === winnerId && maxScore > 0);
            }
        }

        // --- MAPPA & LIVELLO ---
        function buildLevel() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(150,150), new THREE.MeshStandardMaterial({map:floorTexture}));
            floor.rotation.x = -Math.PI/2; 
            if(floorTexture) floorTexture.repeat.set(15,15);
            scene.add(floor);

            const createWindow = (x,y,z,w,rot) => {
                const grp = new THREE.Group(); grp.position.set(x,y,z); grp.rotation.y = rot;
                const mat = new THREE.MeshStandardMaterial({map:wallTexture, color:0xaaaaaa});
                const glass = new THREE.MeshPhysicalMaterial({color:0x111111, metalness:0.9, roughness:0.1, transparent:true, opacity:0.5, side:2});
                
                const bot = new THREE.Mesh(new THREE.BoxGeometry(w,3,1), mat); bot.position.y=-3.5; grp.add(bot);
                const top = new THREE.Mesh(new THREE.BoxGeometry(w,2,1), mat); top.position.y=4.0; grp.add(top);
                const gl = new THREE.Mesh(new THREE.BoxGeometry(w,5,0.2), glass); gl.position.y=0.5; grp.add(gl);
                scene.add(grp);
                
                const col = new THREE.Mesh(new THREE.BoxGeometry(w,10,1), new THREE.MeshBasicMaterial({visible:false}));
                col.position.set(x,y,z); col.rotation.y=rot; scene.add(col);
                colliders.push(new THREE.Box3().setFromObject(col));
            };

            const createWall = (x,y,z,w,h,d) => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({map:wallTexture}));
                m.position.set(x,y,z); scene.add(m); wallMeshes.push(m);
                colliders.push(new THREE.Box3().setFromObject(m));
            };

            // Atrio
            createWall(-6,5,0,1,10,12); createWall(6,5,0,1,10,12);
            createWall(-4.25,5,6,4.5,10,1); createWall(4.25,5,6,4.5,10,1);
            createWall(-4.25,5,-6,4.5,10,1); createWall(4.25,5,-6,4.5,10,1);
            // Corridoio
            createWall(-4,5,-11,1,10,10); createWall(4,5,-11,1,10,10);
            // Sala Grande
            createWall(-8,5,-16,9,10,1); createWall(8,5,-16,9,10,1);
            createWindow(0,5,-36,22,0); // Finestra Nord
            createWall(-11,5,-21,1,10,10); createWall(-11,5,-33,1,10,6);
            createWall(11,5,-21,1,10,10); createWall(11,5,-33,1,10,6);
            // Armeria
            createWall(-25,5,-36,30,10,1); createWall(-25,5,-16,30,10,1);
            createWindow(-40,5,-26,21,Math.PI/2); // Finestra Ovest
            // Santuario
            createWall(16,5,-25,10,10,1); createWall(16,5,-31,10,10,1);
            createWall(21,5,-19.25,1,10,11.5); createWall(21,5,-34.75,1,10,7.5);
            createWindow(35,5,-26,25,Math.PI/2); // Finestra Est
            createWall(28,5,-39,15,10,1); createWall(28,5,-13,15,10,1); createWall(28,5,-26,4,10,4);
            // Cripta
            createWall(-2.5,5,9,1,10,6); createWall(2.5,5,9,1,10,6);
            createWall(-5,5,12,6,10,1); createWall(5,5,12,6,10,1);
            createWall(-8,5,17,1,10,10); createWall(8,5,17,1,10,10);
            createWall(0,5,22,17,10,1);

            // Luci
            const addLight = (x,z,rot) => {
                const l = new THREE.PointLight(0xff6600, 2, 15);
                l.position.set(x+Math.sin(rot)*0.2, 2.8, z+Math.cos(rot)*0.2);
                scene.add(l); torchLights.push({light:l, speed:2+Math.random()*3});
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({map:torchAnimatedTexture, transparent:true, blending:2, side:2, depthWrite:false}));
                plane.position.set(x,2.5,z); plane.rotation.y=rot; scene.add(plane);
            };
            addLight(-5.4,0,1.57); addLight(5.4,0,-1.57);
            addLight(-10.4,-17,1.57); addLight(10.4,-17,-1.57);
            addLight(-20,-35.4,3.14); addLight(-30,-35.4,3.14); addLight(-39.4,-26,1.57);
            addLight(28,-38.4,3.14); addLight(28,-13.6,0); addLight(0,21.4,3.14);
        }

        // --- LOOP PRINCIPALE ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = 0.016;
            if(torchAnimatedTexture) torchAnimatedTexture.needsUpdate=true;
            const t = performance.now()*0.001;
            torchLights.forEach(o => o.light.intensity=30+Math.sin(t*o.speed)*5);

            updateBullets(dt);

            if(isLocked && !isFrozen) {
                // Fisica Movimento
                velocity.y -= GRAVITY*dt;
                velocity.x -= velocity.x*10*dt;
                velocity.z -= velocity.z*10*dt;
                
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y=0; dir.normalize();
                const right = new THREE.Vector3().crossVectors(camera.up, dir).normalize(); // Inversione corretta per ThreeJS (cross order)
                
                // Fix movimento laterale: WASD standard
                // W = dir, S = -dir, A = right, D = -right
                if(moveForward) velocity.add(dir.multiplyScalar(150*dt));
                if(moveBackward) velocity.add(dir.multiplyScalar(-150*dt));
                if(moveLeft) velocity.add(right.multiplyScalar(150*dt)); 
                if(moveRight) velocity.add(right.multiplyScalar(-150*dt));

                playerGroup.position.x += velocity.x*dt;
                if(checkCol(playerGroup.position)) { playerGroup.position.x-=velocity.x*dt; velocity.x=0; }
                playerGroup.position.z += velocity.z*dt;
                if(checkCol(playerGroup.position)) { playerGroup.position.z-=velocity.z*dt; velocity.z=0; }
                
                playerGroup.position.y += velocity.y*dt;
                if(playerGroup.position.y < 0) { playerGroup.position.y=0; velocity.y=0; canJump=true; }

                if(socket?.connected) socket.emit('playerMove', { 
                    x:playerGroup.position.x, y:playerGroup.position.y+0.85, z:playerGroup.position.z, 
                    theta:theta, skin:mySkin, name:myName 
                });
            }

            // Camera
            const head = playerGroup.position.clone().add(new THREE.Vector3(0,1.6,0));
            const dist = isThirdPerson ? 3.5 : 0.1;
            const offset = new THREE.Vector3(Math.sin(theta)*Math.cos(phi), Math.sin(phi), Math.cos(theta)*Math.cos(phi)).multiplyScalar(dist);
            camera.position.copy(head).add(offset);
            camera.lookAt(head); // Guarda sempre la testa
            if(isThirdPerson) avatarMesh.rotation.y = theta + Math.PI;

            renderer.render(scene, camera);
        }

        function checkCol(p) { 
            const box = new THREE.Box3(new THREE.Vector3(p.x-0.4,0,p.z-0.4), new THREE.Vector3(p.x+0.4,2,p.z+0.4));
            return colliders.some(c => box.intersectsBox(c)); 
        }

        // --- SOCKET ---
        function initSocket() {
            socket = io(SOCKET_URL);
            socket.on('connect', () => { 
                console.log("Connected"); 
                scores[socket.id] = 0;
            });
            
            // Gestione messaggi Custom (Hack per usare server chat)
            socket.on('chatMessage', data => {
                const txt = data.text || "";
                
                // EVENTO SPARO: __SHOOT__:x,y,z,vx,vy,vz
                if(txt.startsWith("__SHOOT__:")) {
                    const parts = txt.split(':')[1].split(',').map(parseFloat);
                    // Crea palla remota
                    createBullet(
                        new THREE.Vector3(parts[0], parts[1], parts[2]),
                        new THREE.Vector3(parts[3], parts[4], parts[5]),
                        "remote"
                    );
                    return; 
                }

                // EVENTO COLPO: __HIT__:shooterID:victimID
                if(txt.startsWith("__HIT__:")) {
                    const parts = txt.split(':');
                    const shooter = parts[1];
                    const victim = parts[2];
                    
                    // Aumenta punti dello shooter
                    if(!scores[shooter]) scores[shooter] = 0;
                    scores[shooter]++;
                    
                    // Se sono io lo shooter, aggiorno la mia UI
                    if(shooter === socket.id) {
                        myScore++;
                        document.getElementById('score-display').innerText = myScore;
                    }
                    
                    updateCrowns();
                    return;
                }

                // Chat normale
                const div = document.createElement('div');
                div.innerHTML = `<span class="chat-name">${data.name}:</span> ${txt}`;
                document.getElementById('chat-messages').appendChild(div);
            });

            socket.on('playerMove', data => {
                if(data.id===socket.id) return;
                let p = remotePlayers[data.id];
                if(!p) {
                    // Nuovo Player Remoto
                    const m = avatarMesh.clone(); 
                    m.visible=true;
                    scene.add(m); 
                    setOrUpdateNameTag(m, data.name || "Anonimo");
                    remotePlayers[data.id] = m;
                    scores[data.id] = 0; // init score
                    p = m;
                    // WebRTC Peer
                    if(!peers[data.id]) {
                        const peer = new SimplePeer({initiator:true, stream:localStream});
                        peer.on('signal', s => socket.emit('sendingSignal',{userToSignal:data.id, callerID:socket.id, signal:s}));
                        peer.on('stream', s => { const a=document.createElement('audio'); a.srcObject=s; a.autoplay=true; document.body.appendChild(a); });
                        peers[data.id] = peer;
                    }
                }
                p.position.set(data.x, data.y, data.z);
                p.rotation.y = data.theta + Math.PI;
                if(data.name) setOrUpdateNameTag(p, data.name);
                
                // Cambio colore se congelato (skin hack)
                if(data.skin === "FROZEN") p.material.color.setHex(0x00ffff);
                else {
                    p.material.color.setHex(0xffffff);
                    if(p.userData.skin !== data.skin) {
                        loader.load(`./${data.skin||'plebeo.png'}`, t => { t.colorSpace='srgb'; p.material.map=t; p.material.needsUpdate=true; });
                        p.userData.skin = data.skin;
                    }
                }
            });

            socket.on('playerDisconnected', id => {
                if(remotePlayers[id]) { scene.remove(remotePlayers[id]); delete remotePlayers[id]; }
                if(peers[id]) { peers[id].destroy(); delete peers[id]; }
                delete scores[id];
                updateCrowns();
            });

            // WebRTC Signals
            socket.on('userJoined', p => {
                const peer = new SimplePeer({initiator:false, stream:localStream});
                peer.on('signal', s => socket.emit('returningSignal',{signal:s, callerID:p.callerID}));
                peer.on('stream', s => { const a=document.createElement('audio'); a.srcObject=s; a.autoplay=true; document.body.appendChild(a); });
                peers[p.callerID] = peer;
            });
            socket.on('receivingReturnedSignal', p => { if(peers[p.id]) peers[p.id].signal(p.signal); });
        }
        
        // Setup UI base
        function setupAvatarUI() {
            const updateSkin = () => {
                const s = avatarOptions[currentSkinIndex]; mySkin=s.file;
                document.getElementById('skin-label').innerText = "Skin: "+s.label;
                document.getElementById('hud-propic').src = s.propic;
                loader.load(mySkin, t=>{t.colorSpace='srgb'; avatarMesh.material.map=t;});
                if(socket) socket.emit('skinChange', mySkin);
            };
            document.getElementById('prev-skin-btn').onclick = () => { currentSkinIndex=(currentSkinIndex-1+3)%3; updateSkin(); };
            document.getElementById('next-skin-btn').onclick = () => { currentSkinIndex=(currentSkinIndex+1)%3; updateSkin(); };
            updateSkin();
        }
        function toggleMic() {
            if(!localStream) return; isMicActive=!isMicActive;
            localStream.getAudioTracks()[0].enabled = isMicActive;
            document.getElementById('mic-icon').className = isMicActive ? "fa-solid fa-microphone" : "fa-solid fa-microphone-slash";
            document.getElementById('mic-btn').classList.toggle('active', isMicActive);
        }
        async function setupMusic() {
            document.getElementById('music-btn').onclick = async () => {
                if(!bgMusic) { bgMusic=new Audio(MUSIC_FILE); bgMusic.loop=true; bgMusic.volume=0.3; }
                isMusicOn = !isMusicOn;
                if(isMusicOn) { await bgMusic.play(); document.getElementById('music-icon').className="fa-solid fa-music"; }
                else { bgMusic.pause(); document.getElementById('music-icon').className="fa-solid fa-music"; document.getElementById('music-icon').style.opacity=0.5; }
                document.getElementById('music-btn').classList.toggle('music-on', isMusicOn);
            };
        }
    </script>
</body>
</html>
